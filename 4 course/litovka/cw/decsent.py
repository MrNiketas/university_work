e = 1 # точность

# ищем длину, значение температуры отстаётся неизменным
def find_l(l, t, func):
    h = 0.5# в данном по длине делаем шаг h (положительный), смотрим хуже значение с новой длиной
    k0 = l
    k1 = k0 + h
    if func(k0, t) > func(k1, t): # если хуже, меняем направление на противоположное
        k0 = k1
        h *= -1
        k1 = k0 + h # и делаем шаг

    while func(k0, t) < func(k1, t): # и идём так, пока не станет хуже
        k0 = k1
        k1 = k0 + h

    l = k1 # нашли длину
    return l

# точно также ищется температура, значение длины неизменно
def find_t(l, t, func):
    h = 0.5
    z0 = t
    z1 = z0 + h
    if func(l, z0) > func(l, z1):
        z0 = z1
        h *= -1
        z1 = z0 + h

    while func(l, z0) < func(l, z1):
        z0 = z1
        z1 = z0 + h

    t = z1
    return t

# сам алгоритм оптимизации методом покоординатного спуска
def find_max(l0, t0, l, t, func):
    # l, t - границы для длины и температуры (минимальное и максимальное значение, прописаны в варианте)
    lmin, lmax = l
    tmin, tmax = t

    l_list = [l0]
    t_list = [t0]

    # основной цикл
    while True:
        li = find_l(l0, t0, func) # ищем длину
        li = min(max(li, lmin), lmax) # делаем так, чтоб она попадала в заданные границы
        l_list.append(li) # добавление новых значений в массивы (делается для того, чтоб по этому говну было графики построить)
        t_list.append(t0)

        ti = find_t(li, t0, func) # то же самое, но для температуры
        ti = min(max(ti, tmin), tmax)
        l_list.append(li)
        t_list.append(ti)

        # критерий для остановки
        if ((li - l0) ** 2 + (ti - t0) ** 2) ** 0.5 <= e:
            break

        # текущие значения длины и температуры становятся предыдущими
        l0, t0 = li, ti

    # посчитали, возвращаем все вычисленные значения длины и температуры
    return l_list, t_list